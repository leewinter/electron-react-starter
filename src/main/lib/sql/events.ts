import * as mssql from 'mssql';

import {
  DataChannel,
  EventRequest,
  EventResponse,
  SqlColumn,
  SqlConnectionInspectPayload,
  SqlExecutionRequestPayload,
  SqlExecutionResponsePayload,
  SqlLintPayload,
} from '../../../shared/types/data-channel.d';
import { IpcMainEvent, ipcMain } from 'electron';

import { format } from 'sql-formatter';
import getForeignKeys from './sql-queries/mssql/get-foreign-keys';
import getTableColumns from './sql-queries/mssql/get-table-columns';
import getTablesSql from './sql-queries/mssql/get-tables';
import { parseSqlConnectionString } from './index';

type MssqlTediousColumn = {
  index: number;
  name: string;
  length: number;
  type: () => { name: string };
  scale: number | undefined;
  precision: number | undefined;
  nullable: boolean;
  caseSensitive: boolean;
  identity: boolean;
  readOnly: boolean;
};

const formatSqlInspect = ({ dbTables, dbForeingKeys, dbColumns }) => {
  const result = dbTables.recordset.map((t) => {
    const columns = dbColumns.recordset.filter(
      (c) => c.SchemaName === t.SchemaName && c.TableName === t.TableName,
    );
    const foreignKeys = dbForeingKeys.recordset.filter(
      (fk) => fk.SchemaName === t.SchemaName && fk.TableName === t.TableName,
    );
    return { ...t, columns, foreignKeys };
  });
  return result;
};

const formatSqlResponse = (response) => {
  const columnSets: Array<SqlColumn[]> = Array.isArray(response?.columns)
    ? response.columns.map((columnSet) => {
        return columnSet.map((col: MssqlTediousColumn) => {
          return {
            name: col.name,
            type: col.type.name,
            length: col.length,
            nullable: col.nullable,
            precision: col.precision,
            scale: col.scale,
          } as SqlColumn;
        });
      })
    : [];

  const recordsets = Array.isArray(response?.recordsets) ? response.recordsets : [];
  return { recordsets, columnSets };
};

export const SqlEventsDictionary = {
  [DataChannel.SQL_LINT]: function (): void {
    ipcMain.on(
      `${DataChannel.SQL_LINT}-request`,
      async (event: IpcMainEvent, args: EventRequest<SqlLintPayload>) => {
        console.log('Received from React:', args);

        const formattedCode = format(args.payload.sql, {
          ...args.payload.settings,
          language: 'tsql',
        });
        console.log('formattedCode', formattedCode);
        // Would be generated by some work
        const generatedResponsePayload = {
          channel: DataChannel.SQL_LINT,
          payload: { sql: formattedCode },
        } as EventResponse<SqlLintPayload>;

        // Send a response back to the renderer process
        event.reply(`${DataChannel.SQL_LINT}-response`, generatedResponsePayload);
      },
    );
  },
  [DataChannel.SQL_EXECUTE]: function (): void {
    ipcMain.on(
      `${DataChannel.SQL_EXECUTE}-request`,
      async (event: IpcMainEvent, args: EventRequest<SqlExecutionRequestPayload>) => {
        console.log('Received from React:', args);
        try {
          const sqlConfig = parseSqlConnectionString(
            args.payload.selectedConnection.connectionString,
          );

          await mssql.connect(sqlConfig);
          const request = new mssql.Request();
          request.arrayRowMode = true;
          request.multiple = true;

          const result = await request.query(args.payload.sql);

          const { recordsets, columnSets } = formatSqlResponse(result);

          const generatedResponsePayload = {
            channel: DataChannel.SQL_EXECUTE,
            payload: { error: null, recordsets, columnSets },
          } as EventResponse<SqlExecutionResponsePayload>;

          event.reply(`${DataChannel.SQL_EXECUTE}-response`, generatedResponsePayload);
        } catch (error: any) {
          console.error(error);
          const generatedResponsePayload = {
            channel: DataChannel.SQL_EXECUTE,
            payload: { recordsets: [], columnSets: [], error: error.message },
          } as EventResponse<SqlExecutionResponsePayload>;
          event.reply(`${DataChannel.SQL_EXECUTE}-response`, generatedResponsePayload);
        }
      },
    );
  },
  [DataChannel.SQL_INSPECT_CONNECTION]: function (): void {
    ipcMain.on(
      `${DataChannel.SQL_INSPECT_CONNECTION}-request`,
      async (event: IpcMainEvent, args: EventRequest<SqlConnectionInspectPayload>) => {
        console.log('Received from React:', args);

        try {
          const sqlConfig = parseSqlConnectionString(args.payload.connection.connectionString);

          sqlConfig.validateConfig();

          await mssql.connect(sqlConfig);

          const request = new mssql.Request();

          const dbTables = await request.query(getTablesSql);

          const dbForeingKeys = await request.query(getForeignKeys);

          const dbColumns = await request.query(getTableColumns);

          const result = formatSqlInspect({ dbTables, dbForeingKeys, dbColumns });

          const connection = {
            ...args.payload.connection,
            tables: result,
            lastInspectDate: new Date(),
          };

          const generatedResponsePayload = {
            channel: DataChannel.SQL_INSPECT_CONNECTION,
            payload: { connection },
          } as EventResponse<SqlConnectionInspectPayload>;

          event.reply(`${DataChannel.SQL_INSPECT_CONNECTION}-response`, generatedResponsePayload);
        } catch (error) {
          console.error(error);
        }
      },
    );
  },
};
