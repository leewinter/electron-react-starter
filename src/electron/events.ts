import { ipcMain, IpcMainEvent } from 'electron';
import {type EventRequest, type EventResponse} from '../types/events';
import {DataChannel, DataChannelMethod} from './data-channels';
import { SqlConnection } from '../types/events';
import mssql from 'mssql'
import  {format}  from 'sql-formatter'
import {parseSqlConnectionString} from '../components/sql/utils'


let inMemoryConnections: SqlConnection[] = []

const eventsArray = [
  {
    channel: DataChannel.SQL_CONNECTIONS,
    evenRegister: function () {
      ipcMain.on(`${this.channel}-request`, async (event: IpcMainEvent, args: EventRequest) => {
        console.log("Received from React:", args);

        if(!inMemoryConnections) inMemoryConnections = [];

        if(args.method) {
          if(args.method === DataChannelMethod.POST) {
            const updatedConnections = inMemoryConnections.map(n=>n.connectionId === args.payload.connectionId ? args.payload : n);
            if(!updatedConnections.some(n=>n.connectionId === args.payload.connectionId)) updatedConnections.push(args.payload)
            inMemoryConnections = updatedConnections
          }

          if(args.method === DataChannelMethod.DELETE) {
            const updatedConnections = inMemoryConnections.filter(n=>n.connectionId !== args.payload.connectionId);
            inMemoryConnections = updatedConnections
          }

          // Would be generated by some work
          const generatedResponsePayload = { channel: this.channel, payload: {  connections: inMemoryConnections } } as EventResponse;

          // Send a response back to the renderer process
          event.reply(`${this.channel}-response`, generatedResponsePayload);
        }
      });
    }
  },
  {
    channel: DataChannel.SQL_LINT,
    evenRegister: function () {
      ipcMain.on(`${this.channel}-request`, async (event: IpcMainEvent, args: EventRequest) => {
        console.log("Received from React:", args);    
              
          const formattedCode = format(args.payload.sql)
          console.log("formattedCode", formattedCode)
          // Would be generated by some work
          const generatedResponsePayload = { channel: this.channel, payload: {  sql: formattedCode } } as EventResponse;

          // Send a response back to the renderer process
          event.reply(`${this.channel}-response`, generatedResponsePayload);
        
      });
    }
  },
  {
    channel: DataChannel.SQL_EXECUTE,
    evenRegister: function () {
      ipcMain.on(`${this.channel}-request`, async (event: IpcMainEvent, args: EventRequest) => {
      console.log("Received from React:", args);
        try {
          const sqlConfig = parseSqlConnectionString(args.payload.selectedConnection.connectionString);

          await mssql.connect(sqlConfig);
          const request = new mssql.Request()
          request.arrayRowMode = true

          const result = await request.query(args.payload.sql);

          const recordset = result.recordset ?? [];

          const columns =
            Array.isArray(result?.columns) && Array.isArray(result.columns[0])
              ? result.columns[0].map((col) => {
                  return {
                    name: col.name,
                    type: col.type.name,
                    length: col.length,
                    nullable: col.nullable,
                    precision: col.precision,
                    scale: col.scale,
                  };
                })
              : [];

          
          console.dir(result)
          const generatedResponsePayload = { channel: this.channel, payload: { recordset, columns } } as EventResponse;

          event.reply(`${this.channel}-response`, generatedResponsePayload);
        } catch (error) {
          console.error(error)
        }      
      });
    }
  }
  
];

eventsArray.forEach(e=>e.evenRegister())